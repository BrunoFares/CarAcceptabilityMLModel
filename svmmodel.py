def run_svm_model():    import pandas as pd    from sklearn.pipeline import Pipeline    from sklearn.preprocessing import StandardScaler, LabelEncoder    from sklearn.svm import SVC    from sklearn.metrics import accuracy_score, hinge_loss    from sklearn.model_selection import train_test_split    from scipy.io import arff    import os    import matplotlib.pyplot as plt    # Load dataset using relative path    data, meta = arff.loadarff(os.path.join(os.path.dirname(__file__), 'php2jDIhh.arff'))    df = pd.DataFrame(data)    for col in df.columns:        if df[col].dtype == object:            df[col] = df[col].str.decode('utf-8')    le = LabelEncoder()    for col in df.columns:        df[col] = le.fit_transform(df[col])    X = df.drop('class', axis=1)    y = df['class']    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)    C_values = [10, 30, 50, 70, 90, 110, 200, 400]    accuracies = []    print("üîç Tuning SVM with different C values (gamma=0.1):\n")    for C in C_values:        rbf_kernel_svm_clf = Pipeline([            ("scaler", StandardScaler()),            ("svm_clf", SVC(kernel="rbf", gamma=0.1, C=C))        ])        rbf_kernel_svm_clf.fit(X_train, y_train)        y_pred = rbf_kernel_svm_clf.predict(X_test)        accuracy = accuracy_score(y_test, y_pred)        decision_function = rbf_kernel_svm_clf.decision_function(X)        loss = hinge_loss(y, decision_function)        accuracies.append(accuracy)        print(f"C={C}, Accuracy={accuracy:.4f}, Hinge Loss={loss:.4f}")    # Plot Accuracy vs C values    def accuracygraph():        plt.figure(figsize=(10, 6))        plt.plot(C_values, accuracies, marker='o')        plt.title('SVM Accuracy for Different C Values')        plt.xlabel('C Value')        plt.ylabel('Accuracy')        plt.xticks(C_values)        plt.grid(True)        plt.show()    accuracygraph()